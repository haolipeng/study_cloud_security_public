https://github.com/Tessil/robin-map

google dense hash

intel tbb开源项目



《Comparison of flow tables algorithms for stateful Load Balancers》论文解读

Cuckoo 哈希表可以保证在常量时间内查找， 但插入可能是非常量时间. 我们列出了C++ 实现的多种哈希表，并根据现有的基准和评估 [20,42, 44] 总结了它们的性能。表3.2显示了不同实现的哈希表的比较。



Cuckoo++ shows a better performance on the benchmarks than both optimistic, MemC3

and CUCKOOSWITCH, and pessimistic lookups for Cuckoo. It presents a 50% improve

ment in lookups when working on a single-core scenario and a 45% improvement when

using 18 cores. To avoid most of the unnecessary accesses to the secondary bucket there is

a less than 0.3% false positive rate with the use of the blooming fifilter. This rate indicates

when the fifilter fails to correctly identify whether the secondary bucket needs to be accessed,

and so the secondary bucket is checked without the need to. It also requires less memory

accesses.



Cuckoo++ needs additional metadata to store the bloom fifilter but has 50% less memory

overhead due to the timers. Since Horton and Cuckoo++ have the same memory layout,

Horton also reduces the memory overhead to 50%, but has a higher rate for false positives.

Thus, Cuckoo++ performs better in these aspects. All the positive aspects of lookup that

Cuckoo offffers, worsen with insertion. The cost is higher, but is less important since lookups

tend to take more execution time.



For insertion, Cuckoo++ has a small overhead due to the bloom filter and the timer, but

can be neglected since it is very similar to DPDK’s for large tables. When comparing

Horton with Cuckoo++ [42], no distinction of types is used, and the tag is placed instead

of the bloom filter. Horton has worse performance for all table sizes and worsens as the

load factor increases, since the algorithm for insertion is more complex when the primary

bucket is full. Horton tables also show worse lookup performance when working with higher

load factors

多核评估显示 Cuckoo++ 和 Horton 的查找结果相似， 比 DPDK 的Cuckoo好 45% 左右。



Concury 的内存成本是 Maglev 内存成本的 20%-30% [44]。与 google:dense hash map 相比，CUCKOOSWITCH 在处理小表时性能较差 [52]，但在大表上总体优于google:dense hash map，并总是比google sparse hash map好。



std::unordered map在大多数情况下运行良好 [20]，但受到chain的缓存不友好性的限制。 The tsl::hopscotch map (使用hopscotch哈希) and the tsl::robin map (使用线性robin hood probing) 都是类似Cuckoo哈希的开放寻址方案，对于低负载因子有同等的查询速度。

但是，前者可以在更高的负载因子 (*>*0.6) 下在速度和内存使用之间提供更好的折衷。

The tsl::robin map 插入性能好于 Hopscotch. google::dense hash map（使用二次探测）在较高负载因子场景下，内存中效率不高。此外，它在查找未命中方面表现不佳，就像 emilib::HashMap（使用线性探测）一样。



tsl::sparse map（使用稀疏二次探测）即使在低负载因子下工作，也能在查找时间和内存占用之间很好的折衷，尽管插入速度较慢。它比 google::sparse hash map 和 spp::sparse hash map 都快。

当使用字符串作为键时，tsl::array 映射（使用数组哈希表）提供了对大字符串的最佳查找速度，同时具有最低的内存使用率。

但是，它的 rehash 过程很慢，并且需要备用内存来复制map。 

std::unordered map 和 tsl::ordered map（使用线性罗宾汉探测，桶数组外的键值）只需要在删除时移动一个元素，因此性能更好。



In Table 3.2 we summarize the comparison found on different benchmarks and the papers

of the implementations, with every algorithm in a separate row. And in bold typography

can be found the ones implemented in Section 3.4. Later, Section 3.4.4 details which method we chose to implement, Cucko++, and provides

arguments to support this choice