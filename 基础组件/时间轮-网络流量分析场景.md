在实现代码的时候，采用思维导图梳理清楚实现逻辑。



参考链接：

尤其是这篇文章，一定要好好看下。

**从零到一实现有趣的时间轮算法，你会了吗!**

https://zhuanlan.zhihu.com/p/665545437



**基于 golang 从零到一实现时间轮算法**

https://zhuanlan.zhihu.com/p/658079556



一、时间轮机制



时间轮的超时机制是什么样的，每一个



vpp是多线程，每cpu核心独立的流水线，大量流表按per-worker分片存储，避免跨核心的锁。

“流”在不同功能模块里名字不同：

- Session Layer：transport connections + application sessions，维护 per-worker session tables。

老化触发渠道：

- 定时驱动：wheel/定期扫描器（timer wheel 或周期轮询）推进。
- 数据面访问：包到达时更新 last_seen，并可能触发惰性删除检查。
- 内存/资源压力：达到门限时启动更积极的清理策略。



时间轮的学习



分析下dpvs的时间轮是如何实现的？

疑问点：为什么每级分配524288个链表头？这么多链表头，如何



如何使用呢？

DPVS提供了多种定时器API：

#### 基本定时器操作

- dpvs_timer_sched(): 调度一次性定时器

- dpvs_timer_sched_period(): 调度周期性定时器

- dpvs_timer_cancel(): 取消定时器

- dpvs_timer_reset(): 重启定时器

- dpvs_timer_update(): 更新定时器延迟时间

#### 带锁和不带锁版本

- 带锁版本：dpvs_timer_sched()

- 不带锁版本：dpvs_timer_sched_nolock() - 用于定时器回调函数内部，避免死锁